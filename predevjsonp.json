knowledgebase({
    sections: [{
    items: [{
        title: 'OWASP-SKF',
        body: 'Pre-development items',
        subtitle: 'Pre-development'
                    }, {    
                     title: "SQL commands",
                     attack: "SQL injection ",
                     description: "SQL stands for simple query language and is designed in order for the application to communicate with a database in which it can write and get content from. However, when a attacker can inject malicious code into these queries he gains the ability to manipulate them and now he can withdraw, update and delete data which is stored on the target database.",
                     solution: "The use of prepared statements (aka parameterised queries) is how all developers should first be taught how to write database queries. They are simple to write, and easier to understand than dynamic queries. parameterised queries force the developer to first define all the SQL code, and then pass in each parameter to the query later. This coding style allows the database to distinguish between code and data, regardless of what user input is supplied."     
                    }, {      
					 title: "Path or filenames",
					 attack: "Path/directory traversal",
                     description: "A Path Traversal attack aims to access files and directories that are stored outside the web root folder.  By browsing the application, the attacker looks for absolute links to files stored on the web server.  By manipulating variables that reference files with dot-dot-slash (../); sequences and its variations,  it may be possible to access arbitrary files and directories stored on file system, including application source code,  configuration and critical system files, limited by system operational access control.   The attacker uses ../../ sequences to move up to root directory, thus permitting navigation through the file system. This attack can be executed with an external malicious code injected on the path, like the Resource Injection attack.",
                     solution: "The most effective solution to eliminate file inclusion vulnerabilities is to avoid passing user-submitted input to any filesystem/framework API. If this is not possible the application can maintain a white list of files,  that may be included by the page, and then use an identifier (for example the index number) to access to the selected file.  Any request containing an invalid identifier has to be rejected, in this way there is no attack surface for malicious users to manipulate the path."     
                    }, {      
					 title: "File inclusion",
					 attack: "Path/directory traversal",
                     description: "A Path Traversal attack aims to access files and directories that are stored outside the web root folder.  By browsing the application, the attacker looks for absolute links to files stored on the web server.  By manipulating variables that reference files with dot-dot-slash (../); sequences and its variations,  it may be possible to access arbitrary files and directories stored on file system, including application source code,  configuration and critical system files, limited by system operational access control.   The attacker uses ../../ sequences to move up to root directory, thus permitting navigation through the file system. This attack can be executed with an external malicious code injected on the path, like the Resource Injection attack.",
                     solution: "The most effective solution to eliminate file inclusion vulnerabilities is to avoid passing user-submitted input to any filesystem/framework API. If this is not possible the application can maintain a white list of files,  that may be included by the page, and then use an identifier (for example the index number) to access to the selected file.  Any request containing an invalid identifier has to be rejected, in this way there is no attack surface for malicious users to manipulate the path."     
					}, {      
					 title: "LDAP commands",
					 attack: "LDAP injection",
                     description: "LDAP Injection is an attack used to exploit web based applications that construct LDAP statements based on user input. When an application fails to properly sanitise user input, it is possible to modify LDAP statements using a local proxy. This could result in the execution of arbitrary commands such as granting permissions to unauthorised queries, and content modification inside the LDAP tree. The same advanced exploitation techniques available in SQL Injection can be similarly applied in LDAP Injection.",
                     solution: "The best way to prevent LDAP injection is to use a positive validation scheme for ensuring that the data going into your queries does not contain any attacks. However, in some cases, it is necessary to include special characters in input that is passed into an LDAP query. In this case, using escaping can prevent the LDAP interpreter from thinking those special characters are actually LDAP query. Rather, the encoding lets the interpreter treat those special characters as data."     
					}, {      
					 title: "HTTP headers",
					 attack: "HTTP header injection",
                     description: "HTTP header injection is a general class of web application security vulnerability which occurs when Hypertext Transfer Protocol (HTTP) headers are dynamically generated based on user input. Header injection in HTTP responses can allow for HTTP response splitting (also known as CRLF, Carriage Return Line Feed), Session fixation via the Set-Cookie header, cross-site scripting (XSS), and malicious redirect attacks via the location header. HTTP header injection is a relatively new area for web-based attacks, and has primarily been pioneered by Amit Klein in his work on request/response smuggling/splitting. Vulnerabilities due to HTTP header injections such as CRLF are no longer feasible due to the fact that multiple header requests are not possible.",
                     solution: "When user-input will be used in HTTP headers then the newlines should be escaped in a correct manner."     
                    }, {      
                     title: "XSLT input and output",
                     attack: "XSLT injection",
                     description: "The vulnerability occurs when a XSL file is loaded from a source controlled by an attacker. When the attacker is given the opportunity to specify the source of the included XSL file he could include a file which contains malicious code to be parsed on the target application. This could lead to, code execution, reading arbitrary files and many more vulnerabilities such as XSS.",
                     solution: "To protect against such vulnerability one needs to make sure that he does not use user-supplied input in the XSL filename. The best solution would be to define a list of permitted filenames and only accept XSL filenames from that list."     
                    }, {      
					 title: "SSI commands",
					 attack: "SSI injection",
                     description: "Web servers usually give developers the ability to add small pieces of dynamic code inside static HTML pages, without having to deal with full-fledged server-side or client-side languages.This feature is incarnated by the Server-Side Includes (SSI). In SSI injection testing, we test if it is possible to inject into the application data that will be interpreted by SSI mechanisms. A successful exploitation of this vulnerability allows an attacker to inject code into HTML pages or even perform remote code execution.",
                     solution: "The SSI handler on the web-server should not be activated when it is not used."     
                    }, {      
					 title: "System commands",
					 attack: "Command injection",
                     description: "Command injection is an attack in which the goal is execution of arbitrary commands on the host operating system via a vulnerable application. Command injection attacks are possible when an application passes unsafe user supplied data (forms, cookies, HTTP headers etc.) to a system shell. In this attack, the attacker-supplied operating system commands are usually executed with the privileges of the vulnerable application. Command injection attacks are possible largely due to insufficient input validation. This attack differs from Code Injection, in that code injection allows the attacker to adds his own code that is then executed by the application. In Code Injection, the attacker extends the default functionality of the application without the necessity of executing system commands.",
                     solution: "User-input that is used in a shell command should not contain dangerous characters. A blacklist of characters is not a good option because it may be difficult to think of all of the characters to validate against. A white list containing only allowable characters should be created to validate the user-input."     
					}, {      
					 title: "Private user data",
					 attack: "Identifier based authorization",
                     description: "An application uses parameters in order to process data. These parameters can also be used to assign certain roles and retrieve content corresponding with those parameters. imagine the following example: www.target.com/index.php?loggedin=user In this situation the application will get content and subscribe user roles corresponding to the user parameter www.target.com/index.php?loggedin=admin In this situation the application wil get content and subscribe user roles corresponding to the admin parameter.",
                     solution: "Whenever you are checking whether a user is restricted to review certain data, the access restrictions should be processed server-side. The userID should be stored inside of a session variable on login and should be used to retrieve user data from the database like : SELECT data from personaldata where userID=:id (<- session var) Now an possible attacker can not tamper and change the application operation since the identifier for retrieving the data is handeld server-side."     
					}, {      
					 title: "Eval type functions",
					 attack: "Command injection",
                     description: "Command injection is an attack in which the goal is execution of arbitrary commands on the host operating system via a vulnerable application. Command injection attacks are possible when an application passes unsafe user supplied data (forms, cookies, HTTP headers etc.) to a system shell. In this attack, the attacker-supplied operating system commands are usually executed with the privileges of the vulnerable application. Command injection attacks are possible largely due to insufficient input validation. This attack differs from Code Injection, in that code injection allows the attacker to adds his own code that is then executed by the application. In Code Injection, the attacker extends the default functionality of the application without the necessity of executing system commands. ",
                     solution: "User-input that is used in a shell command should not contain dangerous characters. A blacklist of characters is not a good option because it may be difficult to think of all of the characters to validate against. A white list containing only allowable characters should be created to validate the user-input."     
                    }, {      
					 title: "X-Path",
					 attack: "X-path injection",
                     description: "Web applications heavily use databases to store and access the data they need for their operations. Historically, relational databases have been by far the most common technology for data storage, but, in the last years, we are witnessing an increasing popularity for databases that organise data using the XML language. Just like relational databases are accessed via SQL language, XML databases use X-Path as their standard query language.",
                     solution: "Just like the techniques to avoid SQL injection, you need to use a parameterised X-Path interface if one is available, or escape the user input to make it safe to include in a dynamically constructed query. If you are using quotes to terminate untrusted input in a dynamically constructed X-Path query, then you need to escape that quote in the untrusted input to ensure the untrusted data can not try to break out of that quoted context."     
                    }, {   
                     title: "Regular expressions",
                     attack: "Regular expression injection",
                     description: "If the application uses regular expressions which receives user input, then the user input should be properly escaped. If not done properly then the hacker can affect the regular expression and modify their logic. In some cases, an attacker could even gain access to the server",
                     solution: "Do not use user-input without escaping in a regular expressions 'regex pattern'. Since this could lead to serious security vulnerabilities."     
					}, {      
					 title: "File upload",
					 attack: "File upload injection",
                     description: "Uploaded files represent a significant risk to applications. The first step in many attacks is to get some code to the system to be attacked. Then the attack only needs to find a way to get the code executed. Using a file upload helps the attacker accomplish the first step. The consequences of unrestricted file upload can vary, including complete system takeover, an overloaded file system or database, forwarding attacks to back-end systems, and simple defacement. It depends on what the application does with the uploaded file and especially where it is stored. There are really two classes of problems here. The first is with the file metadata, like the path and file name. These are generally provided by the transport, such as HTTP multi-part encoding. This data may trick the application into overwriting a critical file or storing the file in a bad location. You must validate the metadata extremely carefully before using it. The other class of problem is with the file size or content. An attacker can easily craft a valid image file with php code inside. ",
                     solution: "Uploaded files always needs to be placed outside the document root of the web-server. You should also check the user-input(filename) for having the right allowed extensions such as .jpg, .png etc. note: when checking these extensions always make sure your application validates the last possible extension so an attacker could not simply inject '.jpg.php' and bypass your validation After this validation you must also check the user-input(filename) for containing possible path traversal patterns in order to prevent him from uploading outside of the intended directory. Most developers also do a mime-type check. this is a good protection however not whenever you are checking this mime-type through the post request. This header can not be trusted since it can be easily manipulated by an attacker. The best way to check the mime-type is to extract the file from the server after uploading and check it from the file itself. Deleting it whenever it does not comply with expected values. You may also want to check if the filenames do already exist before uploading in order to prevent the overwriting of files. Also for serving the files back there needs to be a file handler function that can select the file based on an identifier that wil serve the file back towards the user."     
                    }, {      
                     title: "File Download",
                     attack: "Reflective file download/File download injection",
                     description: "Reflective file download occurs whenever an attacker can 'forge' a download through misconfigurations in your 'disposition' and 'content type' headers. Instead of having the attacker to upload a evil file to the webserver he can now force the browser to download a malicious file by abusing these headers and setting the file extension to any type he wants. Now the attacker can present an evil file to ignorant vicim's who are trusting the domain of which the download was presented from. File download injection is a similar type of attack except this attack is made possible whenever there is userinput that is reflected into the "filename=" paramater in the "disposition" header. The attacker again can force the browser to download a file with his own choice of extension and set the content of this file by injecting this directly into the response like: filename=evil.bat%0A%0D%0A%0DinsertEvilStringHere Whenever the user now opens the downloaded file the attacker can gain full control over the targets device.",
                     solution: "First of al never use userinput directly into your headers since an attacker can now take control over it. Secondly you should check if a filename really does exist before presenting it towards the users. You could also create a whitelist of al files which are allowed to be downloaded and terminate requests whenever they do not match. Also you should disable the use of 'path parameters'. It increases the attackers attack vector and these parameters also cause a lot of other vulnerabilities. And last you should sanitise and encode al your userinput as much as possible. reflective file downloads depends on user-input being reflected in the response header. Whenever this input has been sanitised and encoded it should not do any harm to your system."     
                    }, {      
					 title: "XML files",
					 attack: "XML injection",
                     description: "XML Injection is an attack technique used to manipulate or compromise the logic of an XML application or service. The injection of unintended XML content and/or structures into an XML message can alter the intend logic of the application. Further, XML injection can cause the insertion of malicious content into the resulting message/document.",
                     solution: "In addition to the existing input validation, define a positive approach which escapes/encodes characters that can be interpreted as xml. At a minimum this includes the following: < > / '."     
                    }, {      
					 title: "External XML files",
					 attack: "XXE injection",
                     description: "Processing of an Xml eXternal Entity containing tainted data may lead to disclosure of confidential information and other system impacts. The XML 1.0 standard defines the structure of an XML document. The standard defines a concept called an entity, which is a storage unit of some type. There exists a specific type of entity, an external general parsed entity often shortened to an external entity, that can access local or remote content via a declared system identifier and the XML processor may disclose confidential information normally not accessible by the application. Attacks can include disclosing local files, which may contain sensitive data such as passwords or private ",
                     solution: "Disable the possibility to fetch resources from an external source. This is normally done in the config of the used XML parser."     
					}, {      
					 title: "JSON",
					 attack: "XSS",
                     description: "Every time the application gets user-input, whether this showing it on screen or processing this data in the application background, these paramaters should be escaped for malicious code in order to prevent cross site scripting injections. When an attacker gains the possibility to perform a XSS injection, he is given the opportunity to inject HTML and javascript code directly into the application. This could lead to accounts being compromised by stealing session cookies, or directly affect the operation of the target application.",
                     solution: "n order to prevent XSS injections all user-input should be escaped. You could start by encoding user-input as soon as it is inserted into the application, by preference using a so called white-listing method This means u should not checking for malicious content like the tags or anything, but only allowing the expected input. The second step would be encoding al the parameters or user-input before putting this in your html with encoding libraries specially designed for this purpose. Also whenever a user is allowed to add hrefs, make sure the application checks whether the href contains http:// or https://. This is done in order to prevent javascript: or data: type XSS injections. "     
					}, {      
					 title: "GET variables or parameters",
					 attack: "Sensitive data leaking",
                     description: "Authors of services which use the HTTP protocol SHOULD NOT use GET based forms for the submission of sensitive data, because this will cause this data to be encoded in the Request-URI. Many existing servers, proxies, and browsers will log the request URI in some place where it might be visible to third parties. Servers can use POST-based form submission instead. GET parameters are also more likely to be vulnerable to XSS. Please refer to the XSS manual in the knowledge base for more information.",
                     solution: "Whenever transmitting sensitive data always do this by means of the POST request."     
                    }, {      
					 title: "Forward or redirect",
					 attack: "Open forwards & redirects",
                     description: "An open forward is an application that takes a parameter and forwards a user to another part of the application without any validation or access control checks. This may allow an attacker to bypass access control checks, especially those enforced externally, such as by a web server. ",
                     solution: "Use a whitelisting method for determining where the user should be redirected towards."     
                    }, {        
                     title: "third party software",
                     attack: "Version management",
                     description: "Whenever a programmer decides to use third party software, he should keep an eye implementing a proper version management methodology for this software. When hackers discover vulnerabilities they often publish these exploits online in order to push the developers of this software to fix their issues. As a result, when your software is not upgraded to the latest available version, script kiddies could easily compromise your application by following the exploit tutorials online, thus compromising your application.",
                     solution: "One option is not to use components that you did not write. But that is not very realistic. Most component projects do not create vulnerability patches for old versions. Instead, most simply fix the problem in the next version. So upgrading to these new versions is critical. Software projects should have a process in place to: -Identify all components and the versions you are using, including all dependencies. (e.g., the versions plugin). -Monitor the security of these components in public databases, project mailing lists, and security mailing lists, and keep them up to date. -Establish security policies governing component use, such as requiring certain software development practices, passing security tests, and acceptable licenses. -Where appropriate, consider adding security wrappers around components to disable unused functionality and/ or secure weak or vulnerable aspects of the component."     
                    }, { 
                     title: "User registration",
                     attack: "SQL truncation(mysql)",
                     description: "Whenever you allow users to register on your system there are a couple of things you need to take into consideration in order to enforce a high level of security For more detailed information about these items you should check the knowledge-base about: Column truncation sql injection(for mysql databases), Single input validation controls ,audit logs  ,Prevent password leaking ,Predictable password and or token generation ,Are all passwords hashed, salted and stretched ,Does The application enforce the use of secure passwords.",
                     solution: "One option is not to use components that you did not write. But that is not very realistic. Most component projects do not create vulnerability patches for old versions. Instead, most simply fix the problem in the next version. So upgrading to these new versions is critical. Software projects should have a process in place to: -Identify all components and the versions you are using, including all dependencies. (e.g., the versions plugin). -Monitor the security of these components in public databases, project mailing lists, and security mailing lists, and keep them up to date. -Establish security policies governing component use, such as requiring certain software development practices, passing security tests, and acceptable licenses. -Where appropriate, consider adding security wrappers around components to disable unused functionality and/ or secure weak or vulnerable aspects of the component."     
                    }, { 
                     title: "Access controls",
                     attack: "Access controll (pattern)",
                     description: "For successful access control/login functionality there are a lot of things to take into consideration before you start implementing these functions.",
                     solution: "If you design your access/login system with these items into consideration it will save you a lot of time not having to implement them afterwards. Audit logs ,Principle of least privilege (Privilege based authentication system ,Passwords must be encrypted, salted and stretched  ,Security flags(HttpOnly, secure flag, idle timeout, absolute timeout) ,Cross-Site Request Forgery (CSRF for authenticated forms) First, you must implement audit logs in order to trace user requests for forensic purposes whenever an attacker abuses your system. Second, your users table in your database should contain some extra tables and rows for handling the privilege based authentication system, as well as implementing a system for user lock-out when your logging system detects a possible attacker actively attacking your system. After these steps we build a login system with strong password encryption, PDO prepared statements and set security flags for the sessions in order to protect them against XSS and enforce them to be transmitted over only encrypted data lines. And last, now that all the protection layers are in place we want to secure al our data transactions by means of CSRF tokens. note: As soon as the user hits your application you want to enforce him using a https protected connection this can be done by including the Strict-Transport-Security header which looks like: Strict-Transport-Security: max-age=31536000; includeSubDomains  d sAlso you should consider adding your application to a HSTS Preload list for enforcing a higher level of security."     
                    }, {  
                     title: "Sub-domains",
                     attack: "Cross domain cookie injection",
                     description: "A quick overview of how it works: A web site www.example.com hands out subdomains to untrusted third parties One such party, Mallory, who now controls evil.example.com, lures Alice to her site A visit to evil.example.com sets a session cookie with the domain .example.com on Alice's browser When Alice visits www.example.com, this cookie will be sent with the request, as the specs for cookies states, and Alice will have the session specified by Mallory's cookie. Mallory can now use Alice her account. ",
                     solution: "In this scenario changing the sessionID on login does not make any difference since Alice is already logged in when she visits Mallory's evil webpage. It is good practice to use a completely different domain for all trusted activity. For example Google uses google.com for trusted activities and *.googleusercontent.com for untrusted sites. Also when setting your cookies to specify which domains they are allowed to be send to. Especially on your trusted domain you do not want to leak cookies to unintended subdomains. highly recommended is to not use wildcards when setting this option."     
                    }, {             
                     title: "Password forget functions",
                     attack: "Password compromising",
                     description: "Whenever you are implementing a forgot password function into your system there are a few things you need to take into consideration in order to prevent security flaws in your application. ,Forget password functions ,Denial of service by locking out accounts ,Username enumeration  ,Does The application enforce the use of secure passwords ,Disallow the use of old passwords",
                     solution: "The first thing is to verify that forgot password and other recovery paths send a link including a time-limited activation token rather than the password itself. Additional authentication based on soft-tokens (e.g. SMS token, native mobile applications, etc.) can be required as well before the link is sent over. Second, you should not lock out the users account whilst the process of getting a new password is in progress. This could lead to a Denial of service attack whenever an attacker decides to intentionally lock out the users with an automated attack. Third, whenever the new password request was set in progress, the message you display should be generalised in order to prevent username enumeration. Fourth, always disallow the use of old passwords and implement a strong password policy.",
                        }]
    }]
  });
